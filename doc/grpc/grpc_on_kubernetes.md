# gRPC On Kubernetes

## Cluster IP

ClusterIP 模式下，Service 会被分配一个集群内的 IP 地址，客户端的请求会发送给它，然后再通过负载均衡转发给后端某个 pod。

![cluster ip](/resources/kubernetes-cluster-ip.png)

- 如果是基于 HTTP/1.1 协议的服务，那么 ClusterIP 完全没有问题；
- 如果是基于 HTTP/2 协议的服务（如，gRPC 服务），那么 ClusterIP 会导致负载失衡，因为 HTTP/2 协议多个请求在一个 TCP 连接上多路复用，一旦 ClusterIP 和某个 Pod 建立了连接后，后续请求都会被转发给此 Pod。

> 虽然 HTTP/1.1 实现了基于 KeepAlive 的连接复用，但是这里的复用是串行的（HTTP队头堵塞问题），当请求到达的时候，如果没有空闲连接那么就新创建一个连接，如果有空闲连接那么就可以复用，同一个时间点，连接里最多只能承载一个请求，结果是 HTTP/1.1 可以连接多个 Pod；而 HTTP/2 的复用是并行的，当请求到达的时候，如果没有连接那么就创建连接，如果有连接，那么不管其是否空闲都可以复用，同一个时间点，连接里可以承载多个请求，结果是 HTTP/2 仅仅连接了一个 Pod。

## 解决方案

在 Proxy 中实现负载均衡：采用 Envoy 做代理，和每台后端服务器保持长连接，当客户端请求到达时，代理服务器依照规则转发请求给后端服务器，从而实现负载均衡。Proxy 方案结构清晰，客户端不需要了解后端服务器，对架构没有侵入性，但是性能会因为存在转发而打折扣。

在 Client 中实现负载均衡：把服务部署成 **headless service**，这样服务就有了一个域名，然后客户端通过域名访问 gRPC 服务，DNS resolver 会通过 DNS 查询后端多个服务器地址，然后通过算法来实现负载均衡。Client 方案结构复杂，客户端需要了解后端服务器，对架构有侵入性，但是性能更好。